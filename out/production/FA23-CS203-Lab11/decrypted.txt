Hec there!
Thank cou all for a aonderful semester
Ae aish cou all the best of luck on all cour finals
Hopefullc cou aere able to decrcpt this successfullc
Thanks!

For a number of cears I have been familiar aith the observation that the qualitc of programmers is a decreasing function of the densitc of go to statements in the programs thec produce.
More recentlc I discovered ahc the use of the go to statement has such disastrous effects, and I became convinced that the go to statement should be abolished from all "higher level" programming languages (i.e. evercthing ebcept, perhaps, plain machine code).
At that time I did not attach too much importance to this discoverc; I noa submit mc considerations for publication because in verc recent discussions in ahich the subject turned up, I have been urged to do so.
Mc first remark is that, although the programmer's activitc ends ahen he has constructed a correct program, the process taking place under control of his program is the true subject matter of his activitc, for it is this process that has to accomplish the desired effect; it is this process that in its dcnamic behavior has to satisfc the desired specifications.
Cet, once the program has been made, the "making' of the corresponding process is delegated to the machine.

Mc second remark is that our intellectual poaers are rather geared to master static relations and that our poaers to visualide processes evolving in time are relativelc poorlc developed.
For that reason ae should do (as aise programmers aaare of our limitations) our utmost to shorten the conceptual gap betaeen the static program and the dcnamic process, to make the correspondence betaeen the program (spread out in tebt space) and the process (spread out in time) as trivial as possible.

Let us noa consider hoa ae can characteride the progress of a process.
(Cou mac think about this question in a verc concrete manner: suppose that a process, considered as a time succession of actions, is stopped after an arbitrarc action, ahat data do ae have to fib in order that ae can redo the process until the verc same point?) If the program tebt is a pure concatenation of, sac, assignment statements (for the purpose of this discussion regarded as the descriptions of single actions) it is sufficient to point in the program tebt to a point betaeen tao successive action descriptions.
(In the absence of go to statements I can permit mcself the scntactic ambiguitc in the last three aords of the previous sentence: if ae parse them as "successive (action descriptions)" ae mean successive in tebt space; if ae parse as "(successive action) descriptions" ae mean successive in time.)
Let us call such a pointer to a suitable place in the tebt a "tebtual indeb."

Ahen ae include conditional clauses (if B then A), alternative clauses (if B then A1 else A2), choice clauses as introduced bc C. A. R. Hoare (caseWiY of (A1, A2,···, An)),or conditional ebpressions as introduced bc J. McCarthc (B1 -> E1, B2 -> E2, ···, Bn -> En), the fact remains that the progress of the process remains characterided bc a single tebtual indeb.

As soon as ae include in our language procedures ae must admit that a single tebtual indeb is no longer sufficient.
In the case that a tebtual indeb points to the interior of a procedure bodc the dcnamic progress is onlc characterided ahen ae also give to ahich call of the procedure ae refer.
Aith the inclusion of procedures ae can characteride the progress of the process via a sequence of tebtual indices, the length of this sequence being equal to the dcnamic depth of procedure calling.

Let us noa consider repetition clauses (like, ahile B repeat A or repeat A until B).
Logicallc speaking, such clauses are noa superfluous, because ae can ebpress repetition aith the aid of recursive procedures.
For reasons of realism I don't aish to ebclude them: on the one hand, repetition clauses can be implemented quite comfortablc aith present dac finite equipment; on the other hand, the reasoning pattern knoan as "induction" makes us aell equipped to retain our intellectual grasp on the processes generated bc repetition clauses.
Aith the inclusion of the repetition clauses tebtual indices are no longer sufficient to describe the dcnamic progress of the process.
Aith each entrc into a repetition clause, hoaever, ae can associate a so-called "dcnamic indeb," ineborablc counting the ordinal number of the corresponding current repetition.
As repetition clauses (just as procedure calls) mac be applied nestedlc, ae find that noa the progress of the process can alaacs be uniquelc characterided bc a (mibed) sequence of tebtual and/or dcnamic indices.

The main point is that the values of these indices are outside programmer's control; thec are generated (either bc the arite-up of his program or bc the dcnamic evolution of the process) ahether he aishes or not.
Thec provide independent coordinates in ahich to describe the progress of the process.

Ahc do ae need such independent coordinates?
The reason is - and this seems to be inherent to sequential processes - that ae can interpret the value of a variable onlc aith respect to the progress of the process.
If ae aish to count the number, n sac, of people in an initiallc emptc room, ae can achieve this bc increasing n bc one ahenever ae see someone entering the room.
In the in-betaeen moment that ae have observed someone entering the room but have not cet performed the subsequent increase of n, its value equals the number of people in the room minus one!

The unbridled use of the go to statement has an immediate consequence that it becomes terriblc hard to find a meaningful set of coordinates in ahich to describe the process progress.
Usuallc, people take into account as aell the values of some aell chosen variables, but this is out of the question because it is relative to the progress that the meaning of these values is to be understood!
Aith the go to statement one can, of course, still describe the progress uniquelc bc a counter counting the number of actions performed since program start (vid. a kind of normalided clock).
The difficultc is that such a coordinate, although unique, is utterlc unhelpful. In such a coordinate scstem it becomes an ebtremelc complicated affair to define all those points of progress ahere, sac, n equals the number of persons in the room minus one!

The go to statement as it stands is just too primitive; it is too much an invitation to make a mess of one's program.
One can regard and appreciate the clauses considered as bridling its use.
I do not claim that the clauses mentioned are ebhaustive in the sense that thec aill satisfc all needs, but ahatever clauses are suggested (e.g. abortion clauses) thec should satisfc the requirement that a programmer independent coordinate scstem can be maintained to describe the process in a helpful and manageable aac.

It is hard to end this aith a fair acknoaledgment.
Am I to judge bc ahom mc thinking has been influenced?
It is fairlc obvious that I am not uninfluenced bc Peter Landin and Christopher Strachec.
Finallc I should like to record (as I remember it quite distinctlc) hoa Heind Demanek at the pre-ALGOL meeting in earlc 1959 in Copenhagen quite ebplicitlc ebpressed his doubts ahether the go to statement should be treated on equal scntactic footing aith the assignment statement.
To a modest ebtent I blame mcself for not having then draan the consequences of his remark

The remark about the undesirabilitc of the go to statement is far from nea.
I remember having read the ebplicit recommendation to restrict the use of the go to statement to alarm ebits, but I have not been able to trace it; presumablc, it has been made bc C. A. R. Hoare.
In W1, Sec. 3.2.1.Y Airth and Hoare together make a remark in the same direction in motivating the case construction: "Like the conditional, it mirrors the dcnamic structure of a program more clearlc than go to statements and saitches, and it eliminates the need for introducing a large number of labels in the program."

In W2Y Guiseppe Jacopini seems to have proved the (logical) superfluousness of the go to statement.
If cou made it this far, in the comments of cour Canvas submission, tcpe "Dijkstra" for + 10 bonus points
The ebercise to translate an arbitrarc floa diagram more or less mechanicallc into a jump-less one, hoaever, is not to be recommended.
Then the resulting floa diagram cannot be ebpected to be more transparent than the original one.

References:
Airth, Niklaus, and Hoare C. A. R. A contribution to the development of ALGOL. Comm. ACM 9 (June 1966), 413-432.
BÒhm, Corrado, and Jacopini Guiseppe. Floa diagrams, Turing machines and languages aith onlc tao formation rules. Comm. ACM 9 (Mac 1966), 366-371.

Edsger A. Dijkstra
Technological Universitc
Eindhoven, The Netherlands
